export default {
  fullName: "Wael Hasan",
  nationality: "Egyptian",
  title: "Senior Full-Stack JS/TS web developer",
  accountsLinks: {
    linkedinUrl: "https://linkedin.com/in/whsn",
    githubUrl: "https://github.com/waelhasan",
    npmUrl: "https://www.npmjs.com/~whasan/",
    bloggerUrl: "https://waelhasan87.blogspot.com/"
  },
  technicalSkills: [
    { title: 'HTML5', years: 8, level: 90, type: "FRONTEND" },
    { title: 'CSS3', years: 8, level: 80, type: "FRONTEND" },
    { title: 'Javascript', years: 8, level: 90, type: "BOTH" },
    { title: 'Typescript', years: 4, level: 70, type: "BOTH" },
    { title: 'Nodejs', years: 6, level: 70, type: "BACKEND" },
    { title: 'Expressjs', years: 3, level: 80, type: "BACKEND" },
    { title: 'RESTful API design', years: 3, level: 80, type: "BACKEND" },
    { title: 'Graphql', years: 3, level: 70, type: "BACKEND" },
    { title: 'Reactjs', years: 5, level: 80, type: "FRONTEND" },
    { title: 'Redux', years: 1, level: 50, type: "FRONTEND" },
    { title: 'Nextjs', years: 3, level: 75, type: "FRONTEND" },
    { title: 'Jest', years: 3, level: 60, type: "BOTH" },
    { title: 'Cypress', years: 3, level: 70, type: "FRONTEND" },
    { title: 'Storybook', years: 1, level: 55, type: "FRONTEND" },
    { title: 'SQL', years: 3, level: 70, type: "BACKEND" },
    { title: 'Sequelize ORM', years: 1, level: 60, type: "BACKEND" },
    { title: 'Mongodb', years: 2, level: 70, type: "BACKEND" },
    { title: 'Mongoose ODM', years: 2, level: 70, type: "BACKEND" },
    { title: 'Contentful', years: 3, level: 70, type: "BACKEND" },
    { title: 'Git', years: 6, level: 70, type: "BOTH" },
    { title: 'Github', years: 3, level: 65, type: "BOTH" },
    { title: 'Linux', years: 5, level: 60, type: "BOTH" },
    { title: 'Bash', years: 5, level: 60, type: "BOTH" },
    { title: 'Design patterns', years: 8, level: 70, type: "BOTH" },
    { title: 'Gulp', years: 1, level: 70, type: "BOTH" },
    { title: 'Socket.io', years: 1, level: 60, type: "BACKEND" },
    { title: 'Deepstream', years: 1, level: 70, type: "BACKEND" },
    { title: 'Redis', years: 1, level: 60, type: "BACKEND" },
    { title: 'Docker', years: 1, level: 60, type: "BOTH" },
    { title: 'JSON', years: 6, level: 80, type: "BOTH" },
    { title: 'JSON schema', years: 1, level: 80, type: "BOTH" },
    { title: 'Mocha', years: 1, level: 70, type: "BOTH" },
    { title: 'Chai', years: 1, level: 70, type: "BOTH" },
    { title: 'Enzyme', years: 1, level: 70, type: "FRONTEND" },
    { title: 'Tailwind CSS', years: 1, level: 50, type: "FRONTEND" },
    { title: 'SASS', years: 1, level: 50, type: "FRONTEND" },
    { title: 'Yeoman', years: 1, level: 70, type: "BOTH" }
  ],
  softSkills: [
    { title: "Teamwork", years: 8, level: 100 },
    { title: "Leadership", years: 2, level: 65 },
    { title: "Humility", years: 8, level: 100 },
    { title: "Problem-Solving", years: 8, level: 75 },
    { title: "Self-starter", years: 4, level: 80 },
    { title: "Pragmatic", years: 8, level: 90 },
    { title: "Communication", years: 4, level: 80 },
    { title: "Collaboration", years: 8, level: 100 },
    { title: "Mentorship", years: 1, level: 70 },
    { title: "Lifelong learner", years: 8, level: 90 }
  ],
  reasonsToHireMe: [
    "Passion for being a better software engineer",
    "Passion for learning more about technology in general and JS in particular",
    "Fast learner",
    "Passion for building well engineered useful stuff and see people use it happily",
    "Good team player",
    "A lazy developer that searches for the simplest best way to make the code as reliable, self-documenting, and maintainable as possible; so it takes less effort for any change from me or my colleagues"
  ],
  reasonsNotToHireMe: [
    "To do repetitive work, that does not leverage my technical skills",
    "If you work on an industry that contradicts with my faith and believs, or I prefer to stay away from, which are: insurance, racism, porn, weaponary."
  ],
  experience: [
    {
      id: "6",
      title: "Senior Full-Stack JS/TS software engineer",
      company: {
        name: "Andela"
      },
      from: "2019-11-01T08:08:34.527Z",
      to: "2022-08-24T08:08:34.527Z",
      summary: "Worked as a contractor SSE with Andela Inc, which outsourced me to work with Understood for All Inc (remotely). I developed, maintained, tested, and documented multiple Front-end(s) and back-end(s), using technologies such as: JS, TS, Nodejs, Reactjs, Nextjs, Graphql, Contentful, ...etc.",
      type: "REMOTE",
      skills: ["JS", "TS", "Nodejs", "Reactjs", "Nextjs", "Graphql", "Contentful"]
    },
    {
      id: "5",
      title: "Senior Full-Stack Javascript software engineer",
      company: {
        name: "Index Group"
      },
      from: "2018-10-01T08:08:34.527Z",
      to: "2019-10-01T08:08:34.527Z",
      summary: "Worked for Index Group mainly as a Back-end senior developer.",
      type: "ONSITE",
      skills: ["JS", "TS", "Nodejs", "Expressjs", "RESTful services", "Mongodb", "Mongoose", "Deepstream"]
    },
    {
      id: "4",
      title: "Senior Full-Stack software engineer",
      company: {
        name: "Asma Systems"
      },
      from: "2015-01-01T08:08:34.527Z",
      to: "2018-02-01T08:08:34.527Z",
      summary: `Build user interfaces, web services, data layers ... etc. By using:
      - Node js (Sequelize, Mocha and Chai ... etc) on the back end
      - Express js and handlebars, Ext js, or React js on the front end.
      - MongeDB as a database`,
      type: "ONSITE",
      skills: ["JS", "Nodejs", "Reactjs"]
    },
    {
      id: "3",
      title: "Java EE developer",
      company: {
        name: "Truemega Technology Solutions"
      },
      from: "2014-08-01T08:08:34.527Z",
      to: "2014-12-01T08:08:34.527Z",
      summary: "Develop and maintain java EE projects, using jsf, primefaces, EJBs ... etc.",
      type: "ONSITE",
      skills: ["Java", "JEE", "EJB", "PrimeFaces", "JS"]
    },
    {
      id: "2",
      title: "Freelancer developer",
      company: {
        name: "Self employed"
      },
      from: "2011-09-01T08:08:34.527Z",
      to: "2014-08-01T08:08:34.527Z",
      summary: "Develop and maintain different types of software systems.",
      type: "REMOTE",
      skills: []
    },
    {
      id: "1",
      title: "Research assisstant",
      company: {
        name: "C.A.I.R.O Center"
      },
      from: "2010-09-01T08:08:34.527Z",
      to: "2011-11-01T08:08:34.527Z",
      summary: "Image processing development using C++ and OpenCV.",
      type: "ONSITE",
      skills: ["C++", "OpenCV"]
    }
  ],
  projects: [
    {
      id: "graphql-layer",
      title: "Graphql layer",
      company: {
        name: "Andela"
      },
      from: "2021-11-01T08:08:34.527Z",
      to: "2022-08-24T08:08:34.527Z",
      summary: "Created and maintained a Graphql Backend layer. It is an intermediate layer, that allows different Front-ends (Web and Mobile) to call a single Back-end layer, which in turn takes care of calling individual specialized RESTful Back-end services, and other third party services.",
      type: "BACKEND",
      skills: ["JS", "Nodejs", "Graphql", "Contentful", "Redis", "Jest"],
      details: `
> A backend project, that uses Javascript, Nodejs, Apollo Graphql, Redis, and other technologies.
I wrote the greatest majority of it: between 90% to 95% of it's implementation, and built 100% of the test suite (which covered all of the implementation I built, resulting in ~1500 test cases, most of them are e2e tests).

## Main features:

- Receive query/mutation requests from different clients, whether mobile applications or web applications, as the only backend they interact with (excluding authentication and authorization service)
  
  That meant that the pressure on this service was the heighest; as the traffic from all the UIs passes through it, whther it does the heavy lifting, or just wraps the call to another service in a more secute and standarized way.

  That kind of pressure ment that any weakly written implementations would cause a bottleneck in the system, which caused me to be very strict about the kind of code I write (resulting in a high quality code), combined with the deep documentation I buit for the whole codebase, that made it very much maintainable by anyone that knows functional JS programming.

  Also, to guarantee that the code is always as correct as it was, I created an extensive test suite (mostly e2e tests), which covers all the codebase I built. So it became really easy to add/edit/remove code to it, and make sure that every thing is working as expected in just few minutes.

  But creating this test suite was not easy as it seems; because I needed to mock some 3rd party APIs, but there were no 3rd party packages to mock them (or at least they were not working), so I had to mock these services by hand. And in the case of Contentful's RESTful services and Graphql APIs, I built a whole internal package called \`contentful-cameleon\` for mocking these APIs, which made it possible to have the e2e tests without hitting a realy live instance of Contentful, resulting in at least 5 times faster tests.

- Executes the received queries/mutations, by communicating with other inhouse RESTful services, 3rd party services, and data stores (e.g. Contentful, Mongodb), as the only client for these services/data stores.

  Some of these implementations were repeated over and over, such as calling our own RESTful services, so I built custom reusable higher order functions, that wraps the repeated logic, and can be customized if the default behavior is not applicable in our case. That alone caused the codebase complexity to be way less than if we did not have them, and made building new repetitve features (such as calling a GET endpoint, forwarding the inputs to it, and retrning it's result to the callee) a piece of cake, and instead of taking 2 hour to build such repetitive tasks, it only takes half an hour to build it aong with it's e2e tests, and creating the PR for it!  

- Cache different queries' results, handling general queries and user-specific queries.

  Due to the nature of this layer, it became a bottleneck for the system, so I decided that I should build a dedicated caching mechanism for it. That mechanism depended mainly on using Redis to store the dependencies of each query executed by the service, And when one of the dependencies of a query get's invalidated, the cached result gets removed from Redis store, and implementation get's executed to get the latest actual results (which gets cached for sure).

  Building such caching mechanism took some time, and was challenging in all aspects: implementing it, manually testing it, and creating automated e2e tests for it.
  In the implementation I needed to listen to all queries, find a way to extract most of the dependencies, and enable the developers to annotate the rest of the dependencies that can not be obtained automatically, in a clear and easy way that does not make their lives miserable. And I managed to do so using functional programming, building really easy to use higher order functions that wrapped the magic away from the developers.

  In the automated e2e testing, I also built some helper utilities that did the testing in an automated way, and by that I mean that the developer only needed to say that this queery is cacheable, and the testing utility would go and do all the needewd work to test that caching is working perfectly, and that the cache gets invalidated when it should be. That was really hard, but I strived to make it happen; as this is the only guarantee that caching will not brake/misbehave and ruin the functionality of such crucial service. 

- Handle error cases from other services/data stores it interacts with, and send the appropriate error 

  Every service has it's own way of expressing errors, RESTful services does it in a specific way, DBs clients does it in another way ...etc. So I needed to make a unified way for error recovery and resporting, and done so using functional utilities that made every thing happend behind the scenes for the developer, and when a specific behavior is needed that is not aligned with the default behavior, developers have the ability to customize error handling behavior in a clean functional way.       
`
    },
    {
      id: "community-admin",
      title: "Community admin",
      company: {
        name: "Andela"
      },
      from: "2021-11-01T08:08:34.527Z",
      to: "2022-08-24T08:08:34.527Z",
      summary: "An internal Nextjs Front-end for administration tasks related to Wunder App community.",
      type: "FRONTEND",
      skills: ["Ts", "Reactjs", "Graphql", "Contentful", "Cypress"]
    },
    {
      id: "contentful-chameleon",
      title: "Contentful-chameleon",
      company: {
        name: "Andela"
      },
      from: "2020-11-01T08:08:34.527Z",
      to: "2020-08-24T08:08:34.527Z",
      summary: "An internal Nodejs package for mocking Contentful's RESTful/Graphql APIs. Used in e2e tests of other projects.",
      type: "BACKEND",
      skills: ["JS", "TS", "Nodejs", "Graphql", "Contentful", "Jest"]
    },
    {
      id: "camgen",
      title: "Camgen",
      company: {
        name: "Andela"
      },
      from: "2020-11-01T08:08:34.527Z",
      to: "2020-08-24T08:08:34.527Z",
      summary: "An internal yeoman generator for creating new web Front-ends that depends on a specific Contentful structure, and creates that structure on Contentful on behalf of the user.",
      type: "FRONTEND",
      skills: ["JS", "Yeoman", "Contentful", "Jest"]
    },
    {
      id: "mosaic",
      title: "Mosaic",
      company: {
        name: "Andela"
      },
      from: "2019-11-01T08:08:34.527Z",
      to: "2019-08-24T08:08:34.527Z",
      summary: "An internal Contentful App which allows content creators to add data that belongs to dynamic content types.",
      type: "FRONTEND",
      skills: ["TS", "Reactjs", "Graphql", "Contentful", "Jest"],
      details: `
> A front end application that uses Typescript, React, Context API, Contentful SDK, and an inhouse components library. It's main purpose is to enable content creators to choose the React component that they want to show in the web page, then fill the data consumed by that component. 
Contentful allows a limited number of content types, but we needed a lot more types, so we decided to build a type system separate of Contentful's content types, which allows each entry to define it's type to be one of the components in our component library, and we can compose such entries using Mosaic, then the rendering engine (called \`Retina\`) would take care of rendering all of these entries using appropriate components.

## Main features:

- Show a list of the available components from the components library, and enable the user to choose one of them as the type of the entry.

  That part was done by me and the team leader (he was responsible for extracting components list, and I was responsible of ensuring Mosaic will use this list correctly).

- Show input fields that represents the allowed props of the component, along with their types, which can include complex custom-built types, that requires rendereing custom components to enable entering their data (e.g. rich text props that needs rendering a rich text editor in Mosaic to fill it's data).

  The challenge was getting the specifications of each component (props names and types), so I used Typescript's compiler \`tsc\` to get these metadata about the different types, and converted them to a json schema written to a file in the build of the components library. Then in Mosaic I read that file and use it to show the list of components, and render the input fields. The rendering itself was done using a 3rd party library, which took the json schema of the component and built a form that represents it, but we needed to handle rendering complex props.

  Extraxtring the metadata, then converting it to json schema, and finally consuming it from Mosaic was hard, but was a totally necessary automation to make Mosaic use any version of the component library without human intervention of any kind. So when we needed any component, it was the job of the frontend developer to build it in the components library, then a new version of Mosaic would be automatically built and deployed using the new version of the library, and automatically all new components become available in Mosaic.

- Show a preview of the component with the given data, handling happy scenario, and different types of error cases.

  It was challenging to get the data from the input form, including nested data, and then passing it correctly to the chosen component, but I managed to do so using React, in a clean and maintainable way.
  The other challenge was handling the error cases, while using function components as the only type of components. I used a custom error boundary package for functional components, called \`react-error-boundary\`, which helped me handling errors, and still use functional components all the time.
      `
    },
    {
      id: "sekkah",
      title: "Sekkah system",
      company: {
        name: "Freelancing"
      },
      from: "2018-11-01T08:08:34.527Z",
      to: "2018-08-24T08:08:34.527Z",
      summary: "Designed the architecture of 'sekkah' system",
      type: "BOTH",
      skills: ["JS", "HTML5", "CSS3", "Nodejs", "Expressjs", "Socket.io", "Mongodb", "Mongoose", "Reactjs", "Redeux"]
    }
  ]
}